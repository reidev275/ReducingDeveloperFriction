<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.MetadataFormat</name></assembly>
<members>
<member name="">

</member>
<member name="T:FSharp.Collections.Tree`1">
<summary>
 Represents a tree with nodes containing values an a list of children

 [omit]
</summary>
</member>
<member name="M:FSharp.Collections.Tree.ofIndentedList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
 Turns a list of items with an indentation specified by an integer
 into a tree where indented items are children.
</summary>
</member>
<member name="M:FSharp.Collections.Tree.takeDeeperThan``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Takes elements that are deeper (children) and turns them into nodes
</summary>
</member>
<member name="M:FSharp.Collections.Tree.takeAtLevel``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Takes all elements at the specified level and turns them into nodes
</summary>
</member>
<member name="T:FSharp.Collections.Tree">
<summary>
 [omit]
</summary>
</member>
<member name="M:FSharp.Collections.List.nestUnderLastMatching``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 A function that nests items of the input sequence 
 that do not match a specified predicate under the 
 last item that matches the predicate. 
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntilEquals``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions the input list into two parts - the break is added 
 at a point where the list starts with the specified sub-list.
</summary>
</member>
<member name="M:FSharp.Collections.List.startsWith``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Tests whether a list starts with the elements of another
 list (specified as the first parameter)
</summary>
</member>
<member name="M:FSharp.Collections.List.iterInterleaved``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Iterates over the elements of the list and calls the first function for 
 every element. Between each two elements, the second function is called.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntilLookahead``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the 
 specified predicate returns &apos;false&apos;) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntil``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the 
 specified predicate returns &apos;false&apos;) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionWhileLookahead``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the specified predicate 
 returns true) and a rest of the list. The predicate gets the entire 
 tail of the list and can perform lookahead.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the 
 specified predicate returns true) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Collections.List.skipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Skips elements while the predicate returns &apos;true&apos; and then 
 returns the rest of the list as a result.
</summary>
</member>
<member name="M:FSharp.Collections.List.skip``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Skips the specified number of elements. Fails if the list is smaller.
</summary>
</member>
<member name="M:FSharp.Collections.List.singleton``1(``0)">
<summary>
 Returns a singleton list containing a specified value
</summary>
</member>
<member name="T:FSharp.Collections.List">
<summary>
 [omit]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.DocPageTemplateBase`1">
<summary>
 [omit]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.GetMemberBinderImpl">
<summary>
 [omit]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.Html">
<summary>
 For use in the tempaltes (lives in namespace FSharp.MetadataFormat)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.MetadataFormat.MetadataFormat.Generate(Microsoft.FSharp.Collections.FSharpList{System.String},System.String,Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Uri,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.String}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 This overload generates documentation for multiple files specified by the `dllFiles` parameter
</summary>
</member>
<member name="M:FSharp.MetadataFormat.MetadataFormat.Generate(System.String,System.String,Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Uri,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.String}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 This overload generates documentation for a single file specified by the `dllFile` parameter
</summary>
</member>
<member name="T:FSharp.MetadataFormat.MetadataFormat">
<summary>
 This type exposes the functionality for producing documentation from `dll` files with associated `xml` files
 generated by the F# or C# compiler. To generate documentation, use one of the overloades of the `Generate` method.
 The overloads have the following optional parameters:

  - `outDir` - specifies the output directory where documentation should be placed
  - `layoutRoots` - a list of paths where Razor templates can be found
  - `parameters` - provides additional parameters to the Razor templates
  - `xmlFile` - can be used to override the default name of the XML file (by default, we assume
     the file has the same name as the DLL)
  - `markDownComments` - specifies if you want to use the Markdown parser for in-code comments.
    With `markDownComments` enabled there is no support for `&lt;see cref=&quot;&quot;&gt;` links, so `false` is 
    recommended for C# assemblies (if not specified, `true` is used).
  - `typeTemplate` - the templates to be used for normal types (and C# types)
    (if not specified, `&quot;type.cshtml&quot;` is used).
  - `moduleTemplate` - the templates to be used for modules
    (if not specified, `&quot;module.cshtml&quot;` is used).
  - `namespaceTemplate` - the templates to be used for namespaces
    (if not specified, `&quot;namespaces.cshtml&quot;` is used).
  - `assemblyReferences` - The assemblies to use when compiling Razor templates.
    Use this parameter if templates fail to compile with `mcs` on Linux or Mac or
    if you need additional references in your templates
    (if not specified, we use the currently loaded assemblies).
  - `sourceFolder` and `sourceRepo` - When specified, the documentation generator automatically
    generates links to GitHub pages for each of the entity.
  - `publicOnly` - When set to `false`, the tool will also generate documentation for non-public members
  - `libDirs` - Use this to specify additional paths where referenced DLL files can be found
  - `otherFlags` - Additional flags that are passed to the F# compiler (you can use this if you want to 
    specify references explicitly etc.)
  - `urlRangeHighlight` - A function that can be used to override the default way of generating GitHub links

</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.PathTemplateKey">
<summary>
 [omit]
</summary>
</member>
<member name="F:FSharp.MetadataFormat.RazorRender.ViewBag@">
<summary>
 Dynamic object with more properties (?)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.MetadataFormat.RazorRender.ViewBag(RazorEngine.Templating.DynamicViewBag)">
<summary>
 Dynamic object with more properties (?)
</summary>
</member>
<member name="P:FSharp.MetadataFormat.RazorRender.ViewBag">
<summary>
 Dynamic object with more properties (?)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.RazorRender">
<summary>
 [omit]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.RazorRender`1">
<summary>
 [omit]
</summary>
</member>
<member name="">

</member>
<member name="P:FSharp.MetadataFormat.StringDictionary.Item(System.String)">
<summary>
 Report more useful errors when key not found (.NET dictionary does not do this...)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.StringDictionary">
<summary>
 [omit]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.ExtensionMethods">
<summary>
 [omit]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.MetadataFormat.Log.run(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Run the specified I/O interaction in the synchronized log
</summary>
</member>
<member name="M:FSharp.MetadataFormat.Log.logf``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Printf function that prints to a synchronized log
</summary>
</member>
<member name="M:FSharp.MetadataFormat.Log.colored(System.ConsoleColor)">
<summary>
 Can be used to change the console color in a current scope
 (The result is `IDisposable` and can be bound using `use`)
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.Log">

</member>
<member name="M:FSharp.MetadataFormat.Parallel.pfor``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Threading.Tasks.ParallelLoopState,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}})">
<summary>
 Parallel for loop with local state
</summary>
</member>
<member name="T:FSharp.MetadataFormat.Parallel">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.PathHelper">
<summary>
 [omit]
</summary>
</member>
<member name="M:FSharp.MetadataFormat.RazorEngineCache.InvalidateCache(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Invalidates the given razor template files (does nothing for files which aren&apos;t already cached or unknown).
 Use this API only when you know what you are doing. It leaks memory on every call, so you should only use this
 In short lived applications or with an AppDomain recycle strategy in place.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.MetadataFormat.RazorEngineCache.razorCache">
<summary>
 Caching mechanism for IRazorEngineService instances.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.MetadataFormat.RazorEngineCache.tryResolve(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Find file in one of the specified layout roots
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.RazorEngineCache">
<summary>
 A simple RazorEngine caching strategy, this implementation assumes that the current directory never changes.

 [omit]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.MetadataFormat.Reader.readCommentsInto``1(FSharp.MetadataFormat.ValueReader.ReadingContext,System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.FSharp.Core.FSharpFunc{FSharp.MetadataFormat.Comment,``0}}})">
<summary>
 Reads XML documentation comments and calls the specified function
 to parse the rest of the entity, unless [omit] command is set.
 The function is called with category name, commands &amp; comment.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.Reader">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.MetadataFormat.ValueReader">

</member>
<member name="M:FSharp.Patterns.|Command|_|``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Lookup in a dictionary
</summary>
</member>
<member name="M:FSharp.Patterns.|ParseCommand|_|(System.String)">
<summary>
 Utility for parsing commands - this deals with a single command.
 The key of the command should be identifier with just 
 characters in it - otherwise, the parsing fails.
</summary>
</member>
<member name="M:FSharp.Patterns.|ParseCommands|_|(System.String)">
<summary>
 Utility for parsing commands. Commands can be used in different places. We 
 recognize `key1=value, key2=value` and also `key1:value, key2:value`
 The key of the command should be identifier with just 
 characters in it - otherwise, the parsing fails.
</summary>
</member>
<member name="M:FSharp.Patterns.|Let|``2(``0,``1)">
<summary>
 Parameterized pattern that assigns the specified value to the 
 first component of a tuple. Usage:

    match str with
    | Let 1 (n, &quot;one&quot;) | Let 2 (n, &quot;two&quot;) -&gt; n
 
</summary>
</member>
<member name="P:FSharp.Patterns.Lines.|TrimBlankStart|">
<summary>
 Removes whitespace lines from the beginning of the list
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TakeStartingWithOrBlank|_|(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Matches when there are some lines at the beginning that are 
 either empty (or whitespace) or start with the specified string.
 Returns all such lines from the beginning until a different line.
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TrimBlank|(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Removes blank lines from the start and the end of a list
</summary>
</member>
<member name="T:FSharp.Patterns.Lines">

</member>
<member name="M:FSharp.Patterns.List.|AsString|(Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Returns a list of characters as a string.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|BracketDelimited|_|(System.Char,System.Char,Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Matches a list if it starts with a bracketed list. Nested brackets
 are skipped (by counting opening and closing brackets) and can be 
 escaped using the &apos;\&apos; symbol.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|Delimited|_|``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list that is delimited
 using the specified delimiter. Returns a wrapped list and the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|StartsWith|_|``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list. Returns the list.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|DelimitedWith|_|``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list that is delimited
 using the specified delimiters. Returns a wrapped list and the rest.
</summary>
</member>
<member name="T:FSharp.Patterns.List">

</member>
<member name="M:FSharp.Patterns.String.removeSpaces(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Given a list of lines indented with certan number of whitespace 
 characters (spaces), remove the spaces from the beginning of each line 
 and return the string as a list of lines
</summary>
</member>
<member name="M:FSharp.Patterns.String.|EqualsRepeated|_|(System.String,System.String)">
<summary>
 Matches when a string consists of some number of 
 complete repetitions of a specified sub-string.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithWrapped|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with a sub-string wrapped using the 
 opening and closing sub-string specified in the parameter.
 For example &quot;[aa]bc&quot; is wrapped in [ and ] pair. Returns the wrapped
 text together with the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithRepeated|_|(System.String,System.String)">
<summary>
 Matches when a string starts with a non-zero number of complete
 repetitions of the specified parameter (and returns the number
 of repetitions, together with the rest of the string)

    let (StartsWithRepeated &quot;/\&quot; (2, &quot; abc&quot;)) = &quot;/\/\ abc&quot;

</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsAndEndsWithTrim|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with the given value and ends 
 with a given value (and returns trimmed body)
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsAndEndsWith|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with the given value and ends 
 with a given value (and returns the rest of it)
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithTrim|_|(System.String,System.String)">
<summary>
 Matches when a string starts with the specified sub-string
 The matched string is trimmed from all whitespace.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWith|_|(System.String,System.String)">
<summary>
 Matches when a string starts with the specified sub-string
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithAny|_|(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Matches when a string starts with any of the specified sub-strings
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimStartAndCount|(System.String)">
<summary>
 Returns a string trimmed from the start together with 
 the number of skipped whitespace characters
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimEndUsing|(System.Collections.Generic.IEnumerable{System.Char},System.String)">
<summary>
 Retrusn a string trimmed from the end using characters given as a parameter
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimStart|(System.String)">
<summary>
 Returns a string trimmed from the start
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimEnd|(System.String)">
<summary>
 Returns a string trimmed from the end
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimBoth|(System.String)">
<summary>
 Returns a string trimmed from both start and end
</summary>
</member>
<member name="M:FSharp.Patterns.String.|Unindented|_|(System.String)">
<summary>
 Matches when a string does starts with non-whitespace
</summary>
</member>
<member name="M:FSharp.Patterns.String.|WhiteSpace|_|(System.String)">
<summary>
 Matches when a string is a whitespace or null
</summary>
</member>
<member name="T:FSharp.Patterns.String">

</member>
<member name="T:FSharp.Patterns">

</member>
<member name="">

</member>
<member name="T:System.AssemblyVersionInformation">

</member>
<member name="M:Yaaf.FSharp.Scripting.ScriptHost.CreateNew(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Object},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.IO.TextWriter},Microsoft.FSharp.Core.FSharpOption{System.IO.TextWriter},Microsoft.FSharp.Core.FSharpOption{System.IO.TextWriter},Microsoft.FSharp.Core.FSharpOption{System.IO.TextWriter},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Quickly create a new IFsiSession with some sane defaults
</summary>
</member>
<member name="M:Yaaf.FSharp.Scripting.ScriptHost.CreateForwardWriter(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Creates a forwarder Textwriter, which forwards all output to the given function.
 Set revertRedirect only to &quot;false&quot; if you know that f doesn&apos;t print anything to the stdout.
 When revertRedirect is true we capture the Console.Out property and set it before calling f.
 RemoveNewLines
</summary>
</member>
<member name="M:Yaaf.FSharp.Scripting.ScriptHost.Create(Yaaf.FSharp.Scripting.FsiOptions,Microsoft.FSharp.Core.FSharpOption{System.Object},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.IO.TextWriter},Microsoft.FSharp.Core.FSharpOption{System.IO.TextWriter},Microsoft.FSharp.Core.FSharpOption{System.IO.TextWriter},Microsoft.FSharp.Core.FSharpOption{System.IO.TextWriter},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a new IFsiSession by specifying all fsi arguments manually. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Yaaf.FSharp.Scripting.FsiOptions.WarnLevel">
<summary>
 Sets a warning level (0 to 5). The default level is 3. Each warning is given a level based on its severity. Level 5 gives more, but less severe, warnings than level 1.
 Level 5 warnings are: 21 (recursive use checked at runtime), 22 (let rec evaluated out of order), 45 (full abstraction), and 52 (defensive copy). All other warnings are level 2.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Yaaf.FSharp.Scripting.FsiOptions.Default">
<summary>
 Sets a warning level (0 to 5). The default level is 3. Each warning is given a level based on its severity. Level 5 gives more, but less severe, warnings than level 1.
 Level 5 warnings are: 21 (recursive use checked at runtime), 22 (let rec evaluated out of order), 45 (full abstraction), and 52 (defensive copy). All other warnings are level 2.
</summary>
</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.FsiOptions">
<summary>
 See https://msdn.microsoft.com/en-us/library/dd233172.aspx
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yaaf.FSharp.Scripting.IFsiSession.TryEvalExpressionWithOutput(System.String)">
<summary>
 Try to evaluate the given expression and return its result.
</summary>
</member>
<member name="M:Yaaf.FSharp.Scripting.IFsiSession.EvalScriptWithOutput(System.String)">
<summary>
 Evaluate the given script.
</summary>
</member>
<member name="M:Yaaf.FSharp.Scripting.IFsiSession.EvalInteractionWithOutput(System.String)">
<summary>
 Evaluate the given interaction.
</summary>
</member>
<member name="T:Yaaf.FSharp.Scripting.IFsiSession">
<summary>
 Represents a simple F# interactive session.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.FsiExpressionTypeException">
<summary>
 Exception for invalid expression types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.FsiEvaluationException">
<summary>
 This exception indicates that an exception happened while compiling or executing given F# code.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.Helper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.ArgParser">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.Shell.InteractiveSettings">
<summary>
 Implements a simple &apos;fsi&apos; object to be passed to the FSI evaluator
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.Shell.SimpleEventLoop">
<summary>
 Represents a simple (fake) event loop for the &apos;fsi&apos; object
</summary>
</member>
<member name="T:Yaaf.FSharp.Scripting.Shell">

</member>
<member name="M:Yaaf.FSharp.Scripting.Extensions.IFsiSession.Handle``1(Yaaf.FSharp.Scripting.IFsiSession,Microsoft.FSharp.Core.FSharpFunc{System.String,``0},System.String)">
<summary>
 Handle the given evaluation function
</summary>
</member>
<member name="M:Yaaf.FSharp.Scripting.Extensions.IFsiSession.WithCurrentDirectory``1(Yaaf.FSharp.Scripting.IFsiSession,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Same as ChangeCurrentDirectory but takes a function for the scope.
</summary>
</member>
<member name="M:Yaaf.FSharp.Scripting.Extensions.IFsiSession.ChangeCurrentDirectory(Yaaf.FSharp.Scripting.IFsiSession,System.String)">
<summary>
 Change the current directory (so that relative paths within scripts work properly).
 Returns a handle to change the current directory back to it&apos;s initial state 
 (Because this will change the current directory of the currently running code as well!).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yaaf.FSharp.Scripting.Extensions.IFsiSession.Let``1(Yaaf.FSharp.Scripting.IFsiSession,System.String,``0)">
<summary>
 Assigns the given object to the given name (ie &quot;let varName = obj&quot;) 
</summary>
</member>
<member name="M:Yaaf.FSharp.Scripting.Extensions.IFsiSession.EvalExpression``1(Yaaf.FSharp.Scripting.IFsiSession,System.String)">
<summary>
 Evaluate the given expression and return its result.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.Extensions">

</member>
<member name="M:Yaaf.FSharp.Scripting.CompilerServiceExtensions.Type.get_FSharpFullNameWithTypeArgs(System.Type)">
<summary>
 Gets a string that can be used in F# source code to reference the current type instance.
</summary>
</member>
<member name="M:Yaaf.FSharp.Scripting.CompilerServiceExtensions.Type.get_FSharpParamList(System.Type)">
<summary>
 The parameter list of the current type, sets &quot;_&quot; if the current instance is a generic definition.
</summary>
</member>
<member name="M:Yaaf.FSharp.Scripting.CompilerServiceExtensions.Type.get_FSharpFullName(System.Type)">
<summary>
 Gets the FullName of the current type in F# source code.
</summary>
</member>
<member name="M:Yaaf.FSharp.Scripting.CompilerServiceExtensions.Type.get_FSharpName(System.Type)">
<summary>
 The name of the current type instance in F# source code.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yaaf.FSharp.Scripting.CompilerServiceExtensions.Type.get_NamespaceName(System.Type)">
<summary>
 The FullName but without any generic parameter types.
</summary>
</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.CompilerServiceExtensions.TypeParamHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.CompilerServiceExtensions.TypeNameHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.CompilerServiceExtensions.FSharpAssemblyHelper">

</member>
<member name="T:Yaaf.FSharp.Scripting.CompilerServiceExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yaaf.FSharp.Scripting.Env">

</member>
</members>
</doc>
